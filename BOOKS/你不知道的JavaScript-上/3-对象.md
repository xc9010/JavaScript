### 对象

- 1，语法
```
    对象可以通过两种形式定义：

    1，声明形式：
    var obj = {
        key: value
    };

    2，构造形式：
    var obj = new Object();
    obj.key = value;

    唯一的区别是：在文字声明中你可以添加多个键/值对，但在构造行驶中必须逐个添加属性
```

- 2，类型

> 对象是JavaScript的基础，一共有六种主要类型
    - string
    - number
    - boolean
    - null
    - undefined
    - object

```
    1，基本类型
    简单基本类型本身不是对象，null会被当做对象，因为语言本身的bug，实际上null本身是基本类型

    有一种常见的错误说法：JavaScript中万物皆是对象，这是错误的

    JavaScript中有许多特殊的对象子类型，称之为：复杂基本类型

    1，函数
        是对象的一个子类型。
        函数是一等公民，本质上和普通的对象一样，所以可以像操作对象一样操作函数
    
    2，数组
        是对象的一种类型，具备一些额外的行为
        数组中内容的组织方式比一般的对象要稍微复杂一些
```

#### 内置对象

> 内置对象：JavaScript中还有一些对象子类型

- String
- Number
- Boolean
- Object
- Function
- Array
- Date
- RegExp
- Error

```
    这些内置函数可以当做构造函数来使用，从而可以构造一个对应子类型的新对象

    原始值 'string' 并不是一个对象，只是一个字面量，并且是一个不可变的值
    如果要在这个字面量上执行一些操作，比如获取长度，访问某个字符，则需要将其转换为String对象

    在必要时语言会自动把字符串字面量转换成String对象，不需要显式创建一个对象

    null和undefined 没有对应的构造形式，只有文字形式
    相反，Date只有构造，没有文字形式

```

```
    对于Object、Array、Function、RegExp来说，无论文字还是构造，都是对象，不是字面量

    Error对象很少在代码中显式创建，一般是抛出异常时被自动创建，也可以使用new Error()这种构造形式创建
```

- 3，内容

> 对象的内容是：由一些存储在特定命名位置的值组成的，我们称之为属性

当我们说内容时，似乎在暗示这些值实际上被存储在对象内部，但是这只是它的表现形式。

引擎内部，值的存储方式是多种多样的，一般不会存在对象容器内部。

存储在对象容器内部的是这些属性的名称，就像指针一样，指向这些值真正的存储位置。

#### 属性访问

```
var obj = {
    a: 2
}

obj.a; // 2
obj['a']; // 2
```
##### 属性名永远都是字符串
```
var obj = {};

obj[true] = 'foo';
obj[3] = 'bar';
obj[obj] = 'baz';

obj['true']; // 'foo'
obj['3']; // 'bar'
obj['[object object]']; // 'baz'
```

#### 可计算的属性名
> [''] 可以进行字符串拼接

#### 属性与方法

> 如果访问的对象属性是一个函数，有些开发者喜欢使用不一样的叫法以作区分

从技术角度说，函数永远不会属于一个对象，所以对象内部引用的函数称为‘方法’，有点不妥

有些函数具有this引用，有时候这些this确实会指向调用位置的对象引用

但是这种用法从本质上来说没有把一个函数变成一个方法， 因为this是在运行时根据调用位置动态绑定的，所以函数和对象的关系最多也只能说是间接关系

无论返回值是什么类型，每次访问对象的属性就是属性访问。

如果属性访问返回的是一个函数，那它也不是一个方法，

属性访问返回的函数和其他函数没有任何区别（除了可能发生的隐式绑定this）

```
function foo() {
    console.log('foo')
}

var someFoo = foo;

var myObj = {
    someFoo: foo
};

foo; // function foo() {...}

someFoo; // function foo() {...}

myObj.someFoo; // function foo() {...}

someFoo和myObj.someFoo只是对于同一个函数的不同引用，不能说明这个函数是特别的或者属于某个对象
如果foo()定义时在内部有一个this引用，那这两个函数引用的唯一区别就是this的指向

```

```
即使在对象的文字形式中声明一个函数表达式，这个函数也不会属于这个对象——只是对于相同函数对象的多个引用

var myObj = {
    foo: function() {
        console.log('foo')
    }
}

var someFoo = myObj.foo;

someFoo; // function foo(){...}

myObj.foo; // function foo(){...}

```

#### 数组
> 数组也支持[]访问，数组有一套更加结构化的值存储机制。

数组期望的是数值下标，也就是说值存储的位置是非负整数，

数组也是对象，也可以添加属性
```
var arr = [1,2,3]

arr.baz = 'baz';
arr.length; // 3
arr.baz; // 'baz'

```
可以看到虽然添加了属性，但是数组的length值并未发生变化

数组完全可以当做一个普通的键值对象来使用，并且不添加任何数值索引
但是这样不好，数组和普通对象都根据其对应的行为和用途进行了优化，

所以，最好还是只用对象来存储键值对，数组来存储下标值对


#### 复制对象
[详见JS-11-深浅拷贝]

#### 属性描述符


#### 不可变性

#### [[Get]]

#### [[Put]]

#### Getter和Setter

#### 存在性




- 【4，遍历】