### 1，作用域是什么



---

- 当前函数[[scope]] = 当前函数创建时候所在的上下文

```
个人总结：
当前函数的作用域是取决于创建函数时候的上下文，是哪个上下文创建的，它的作用域就是谁
```
- 全局变量VS私有变量
    - 全局变量: 在全局上下文EC(G)中的全局变量对象VO(G)中，存储的变量
    - 私有变量：在函数执行形成的私有上下文EC(XXX)中的变量对象AO(XXX)中，存储的变量
    - 私有变量具体有哪些：1，当前函数执行的上下文中：声明过的函数或对象，都会存储到AO(XXX)；2，函数定义的形参变量，会存储到AO(XXX)中

> 一句话概括：使用一套严格的规则来分辨哪些标识符（变量）对那些语法有访问权限。
---

#### 1.1 编译原理

```
JavaScript通常归纳于‘动态’或‘解释执行’语言，但事实上它是一门编译语言。
与传统的编译语言不同的是，它不是提前编译的，编译结果也不能在分布式系统中进行移植。
```

> 看下传统的编译过程


- 词法分析/分词
```
    这个过程会将
    由字符组成的字符串分解成有意义的代码块，
    这些代码块就是词法单元（token）
```
- 语法分析/解析
```
    这个过程将
    词法单元流（数组）
    转换成一个由元素
    逐级嵌套所组成的
    代表了程序语法结构的树 —— 抽象语法树（AST）
```

- 代码生成
```
    将AST转换为
    可执行代码的过程
    
    这个过程与语言、目标平台息息相关
```

> 实际上JavaScript引擎比上面三个步骤还要复杂，比如词法分析和代码生成阶段有特定的步骤来对运行性能进行优化


```
    首先，JavaScript不会有大量的时间用来进行优化，它的编译过程不是发生在构建之前的
    
    大部分情况下，编译发生在代码执行前的几微秒（甚至更短）的时间内，
    JavaScript引擎用了各种办法（JIT，可以延迟编译甚至实施重编译）来保证性能最佳
    
    简单的说，任何JavaScript代码片段在执行前都要进行编译
    因此，JavaScript编译器首先会对代码进行编译，然后马上执行它
```

---


#### 1.2 理解作用域

```
    例子: var a = 2;
    
    把它分解：
    
    遇到var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。
    
    如果是，引擎就会使用这个变量，
    如果否，引擎会继续查找该变量，
    
    接下来，编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。
    
    引擎运行时候会首先询问作用域，当前的作用域集合中是否存在一个叫a的变量
    
    如果是，引擎就会使用这个变量，
    如果否，引擎会继续查找该变量，
    
    引擎最终找到了a变量，会将2赋值给它。否则引擎就会抛出一个异常。
    
```

> 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量，然后在运行时引擎会在作用域中查找该变量，如果能够找到就对它进行赋值。

 - 关于编译器的术语
 
```
    当变量出现在赋值操作的左侧时，进行LHS查询 (= 2)
    出现在右侧时，进行RHS查询(var a)
    
    LHS查询是试图找到变量的容器本身，从而可以对其赋值
    RHS查询与简单地查找某个变量的值别无二致，并不是真正意义上的赋值操作的右侧，准确的说是非左侧
    
    RHS可以理解成retrieve his source value (取到它的源值)，得到某某的值
```

```
    console.log(a)
    
    这行代码，其中对a的引用是一个RHS引用，因为对a并没有赋予任何的值
    
    a = 2
    
    这行代码，对a的引用则是LHS引用，实际上不关心a的值是什么，只是想要为 = 2这个赋值操作找到目标
```

---

#### 1.3 作用域的嵌套


> 作用域是根据名称查找变量的一套规则

```
当一个块或函数嵌套在另一个块或函数中时，就发生了作用域嵌套，
因此，在当前作用域中无法找到某个变量的时候，引擎就会在外层作用域中继续查找
一直到找到该变量或者抵达最外层的作用域（即全局作用域）为止
```

#### 1.4 异常

> 为什么区分LHS和RHS是一件很重要的事情

```
    因为在变量还没有声明的情况下（在任何作用域中都无法找到该变量），这两种查询的行为是不一样的
    
    function foo(a) {
        console.log(a+b);
        b = a;
    }
    foo(2)
    
```
```
第一次对b的RHS查询时，是无法找到该变量的，这是一个‘未声明’的变量，因为在任何相关的作用域中都无法找到它

如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError异常

注意：ReferenceError异常 是非常重要的异常类型

相比较之下，当引擎执行LHS查询时，如果在顶层也无法找到目标变量，就会创建一个具有该名称的变量，并返回给引擎，前提是程序运行在非‘严格模式’下

‘严格模式’下，LHS查询失败时，并不会创建一个全局变量，抛出一个同RHS类似的ReferenceError异常

接下来，如果RHS查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，（比如对非函数进行函数调用，引用null或undefined类型的值中的属性）会报另外一种类型的异常 —— TypeError

ReferenceError异常同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的
```
