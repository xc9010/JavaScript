### this

#### 1-为什么要用this

> 可以在不同的上下文对象中重复使用函数，不用针对每个对象编写不同版本的函数
> 如果不使用this，就需要给函数显式的传入一个上下文对象

- this提供了一种更优雅的方式来隐式'传递'一个对象的引用，API可以设计的更加简洁，易于复用
- 当使用模式越来越复杂，显式传递上下文对象会让代码变得越来越混乱，所以使用this就不会这样


#### 2-误解

> 对于this有两种解释是错误的

- 1-指向自身
```
    人们很容易把this理解成指向自身

    那么为什么需要从函数内部引用函数自身呢，常见的原因就是递归，或者写一个第一次调用后自己解除绑定的事件处理器

    如果要从函数对象内部引用它自身，只使用this是不够的；
    一般来说，需要通过一个指向函数对象的词法标识符（变量）来引用它

```
```
// 一种强制this指向foo函数对象
    function foo(num) {
        console.log('foo', + num)
        this.count++;
    }

    foo.count = 0;

    var i;

    for(i=0;i<10;i++){
        if (i>5) {
            foo.call(foo, i)
        }
    }
```

- 2-它的作用域
```
    第二种常见的误解是，this指向函数的作用域。
    有点复杂了，某些情况下是正确的，某些情况下是错误的。

    需要明确的是，this在任何情况下都不指向函数的词法作用域。

    在JavaScript内部，作用域和对象类似，可见的标识符都是它的属性；
    但是作用域'对象'无法通过JavaScript代码访问，它存在于JavaScript引擎内部；

```

```
如下代码，试图跨越边界，但是没成功，使用this来隐式引用函数的词法作用域
    function foo() {
        var a = 2;
        this.bar();
    }

    function bar() {
        console.log(this.a)
    }

    foo(); // a is not defined

1，试图通过this.bar()来引用bar()函数，其实最简单的方法是省略this，直接使用词法作用域

2，还试图使用this联通foo()和bar()的词法作用域，从而让bar()可以访问foo()作用域里面的变量a，这是错误的，使用this不可能在词法作用域中查到什么

```



#### 3-this到底是什么

```
    当一个函数被调用时，会创建一个活动记录(AO,执行上下文)。这个记录会包含函数在哪里被调用、函数的调用方式、传入的参数等信息；
    this就是这个记录的一个属性，会在函数执行的过程中用到；

    this是在运行时进行绑定的，并不是在编写时绑定的，它的上下文取决于函数调用时候的各种条件；

    this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式
```
