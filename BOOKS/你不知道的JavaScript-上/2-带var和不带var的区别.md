
### 带var和不带var的区别

#### 全局对象/全局变量对象 的区别
    - 1，全局对象： 浏览器会默认自带很多供JS调用的API，这些属性都在GO（global object）中储存着，在浏览器端，GO对象赋值给window；在node里，赋值给global
    - 2，全局变量对象：在全局代码执行过程中，会声明一些变量，这些变量存储在（全局变量对象VO）中
    - ！！完全是两个不同的东西
    
#### 总结
-   全局对象：是浏览器自带的存储属性和方法的堆，是一个对象
-   全局变量对象：是我们自己写代码创建的变量要存储的地方，是栈内存


---

#### 在全局执行上下文中——带var和不带var的区别

-  带var：是创建一个全局变量，存储在VO中
-  不带var：创建的不是变量，而是全局变量GO的一个属性
-  带var：基于var创建变量，会给GO，VO各自储存一份
-  不带var：只是给GO设置一个属性而已

> 当输出这个变量值时，先看是否为全局变量，是则输出，否则再看是否为全局对象的属性，如果再不是，则报错

#### 在私有执行上下文中——带var和不带var的区别

- 带var：在私有上下文AO变量对象中，声明一个私有变量（这个私有变量是当前上下文的私有变量，和上下文以外没有必然联系）
- 不带var：y = 200
    -   如果浏览器发现y不是私有变量，则向上下文中查找（按照作用域链），一直找到全局作用域，找到哪一级，就是哪一级的变量
    -   如果全局都没有找到，则给GO设置一个属性window.y = 200
    
#### 全局和私有上下文中带var的区别

-   全局执行上下文中，基于var创建变量，会给VO，GO中各自存储一份
-   私有执行上下文中，只在私有变量对象AO中创建了变量，没有给window添加属性



---
```
/*
 * 全局上下文中的变量提升
 *     var a;
 *       ->给VO(G)中新增一个全局变量 a
 *       ->给GO中新增一个属性 a
 *       ->默认值都是 undefined
 */
console.log(a); //=>undefined
if (!('a' in window)) {
	// 'a' in window 检测a是否为window的一个属性 =>TRUE
	// !true => FALSE  条件不成立
	var a = 13;
}
console.log(a); //=>undefined
```
```
/*
 * 全局上下文中的变量提升（最新版本浏览器中）
 *     function fn;
 *       ->VO(G)中存在一个fn全局变量
 *       ->GO中存在一个fn属性
 */
console.log(fn); //=>undefined
// fn();//=> undefined() =>Uncaught TypeError: fn is not a function  JS中，一但当前代码报错，那么下面的代码都不会再执行了
if ('fn' in window) { 
	fn(); 
	function fn() {
		console.log('哈哈哈');
	}
}
fn();

//================================================

/*
 * 全局上下文中的变量提升（最新版本浏览器中）
 *     function fn;
 *       ->VO(G)中存在一个fn全局变量
 *       ->GO中存在一个fn属性
 */
console.log(fn); //=>undefined
if ('fn' in window) {  //=>TRUE
	// 进来第一件事情：给FN赋值  fn=function(){ ... }
	fn(); //=>'哈哈哈'
	function fn() {
		console.log('哈哈哈');
	}
}
fn(); //=>'哈哈哈'
```
