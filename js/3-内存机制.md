# JavaScript内存机制

## 目录
1.JS 原始数据类型的变量声明和赋值
2.JS 内存模型：调用堆栈和堆
3.JS 引用类型的变量声明和赋值
4.let vs const
```
// 声明变量然后初始化
var a = 100;
let b = 'number';
const c = true;
```

## 1.JS 原始数据类型的变量声明和赋值
```
let num = 100;    
```
```
变量名 -> 内存地址 -> 值
  num -> 000XXXXXX -> 100
```
#### 技术上num只是等于000XXXXXX这个内存地址，而这个内存地址里所存的值才是100；

```
let newNum = num;
```
```
变量名 -> 内存地址 -> 值
  newNum -> 000XXXXXX -> 100
```
所以当我们进行如下操作时候
```
num = num + 100
num: 200
newNum: 100
```
#### 因为原始数据类型的值是不可变的，所以当操作num+100时候，内存中分配了一个新的内存地址，而此时newNum还是指向原来的地址，所以他们不等
```
变量名 -> 内存地址 -> 值
  newNum -> 000XXXXXX -> 100
  num -> 000XXXXX1 -> 200
```


    
    
## 2.JavaScript 内存模型：调用堆栈和堆

##### JS 内存模型可以理解为有两个不同的区域:调用堆栈(call stack)和堆(heap)

调用堆栈是存放原始数据类型的地方(除了函数调用之外)
堆是存储引用类型的地方
##### 区别在于，堆可以存储无序的数据，这些数据可以动态地增长，非常适合数组和对象。


## 3.JS 引用类型的变量声明和赋值

```
let arr = [];
```
```
变量名 -> call stack内存地址 -> call stack值 -> leap内存地址 -> leap值
arr   ->      0000A        ->   0000B     ->    000B     ->  []
```
```
arr.push("1");
arr.push("2");
arr.push("3");
arr.push("4");
arr.pop();
// 此时这里操作的是leap里面的值，arr依然等于 000A -> 000B -> [1,2,3]
```

## 4.let vs const

```
let: 当我们知道某个变量将发生改变时；
const: 定义一个不可修改的常量，且不能为空；

let num = 0;
num = 1 + 2 + 3 + 4 + 5;
let nums = [];
nums.push(1);
nums.push(2);
nums.push(3);
nums.push(4);
nums.push(5);
```

#### 当我们使用let声明num时候，是知道num的值会改变的；
#### 但是使用let声明nums是错误的，因为他将把数据推入数组理解为了改变数组的值

#### '改变'的正确方法是更改内存地址。let是允许更改内存地址的，const不允许

```
const num = 500;
num = 1; // Uncaught TypeError: Assignment to constant variable.

why?
当声明num时，分配了一个内存地址，并存储500的值，
变量名 -> 内存地址 -> 值
  num -> 000XXXXXX -> 500
  
1，当将500分配给num时，因为500是一个原始数据类型，所以会分配一个新的内存地址，并将500的值存储在这个内存地址里
2，然后JS尝试将新的内存地址分配给num，这里就是抛出错误的地方，当你将1分配给num时，实际上是在尝试分配存储1的新内存的地址，这是不允许的，因为num是用const声明的；
```

#### 所以，我们上面使用let声明nums数组是错误的，应该用const来声明；

```
变量名 -> 内存地址   -> 值          -> 内存地址   ->  值
  arr -> 000XXXXXX -> 111XXXXXX  -> 111XXXXXX -> []
  arr -> 000XXXXXX -> 111XXXXXX  -> 111XXXXXX -> [1,2,3,4,5]
// 当我们执行push操作时，实际上是将数字放入对重存在的数组，而arr的内存地址没有改变，这就是为什么使用const声明了arr，但没有抛出任何错误的原因
```

#### 下面是两个会导致报错的场景

```
arr = 10;
// 原因
变量名 -> 内存地址   -> 值          -> 内存地址   ->  值
  arr -> 000XXXXXX -> 111XXXXXX  -> 111XXXXXX -> []
  arr -> 000XXXXXX -> 10
// 由于10是一个原始数据类型，因此生成一个新的调用堆栈上的内存地址，值为10，然后将新的内存地址分配给arr,由于arr是const声明的，所以是错误的；
```

```
arr = [10]
// 原因
变量名 -> 内存地址   -> 值          -> 内存地址   ->  值
  arr -> 000XXXXXX -> 111XXXXXX  -> 111XXXXXX -> []
  arr -> 333XXXXXX -> 444XXXXXX  -> 444XXXXXX -> [10]
// [10]是一个新的引用类型的数组，因此将分配调用堆栈上的一个新的内存地址，并存储堆上的一个内存地址的值，值为[10]，然后将调用堆栈内存地址分配给arr,这里会抛出错误；
```

#### 使用const或let声明所有变量来代替var，默认情况下使用const，除非需要重新分配变量；
#### 代码可读性增强，一看就知道哪些变量可变，哪些变量不可变
